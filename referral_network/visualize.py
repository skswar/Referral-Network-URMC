# -*- coding: utf-8 -*-
"""NSA_Final_Project_NewDataset_FlaskReady.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lVJ42W_sP2UlHTPt8J75OKvezVLYPVRv
"""


import json
from typing import Optional

import pandas as pd
import numpy as np
# import matplotlib.pyplot as plt
# import seaborn as sns
# from skimpy import skim
import networkx as nx
import plotly
import plotly.graph_objects as go
import plotly.offline as py
# from pyvis.network import Network
from collections import deque
from sklearn.preprocessing import MinMaxScaler, StandardScaler
import networkx.algorithms.community as nxcom


pd.options.mode.chained_assignment = None  # default='warn'


def queue(a, b, qty):
    """either x0 and x1 or y0 and y1, qty of points to create"""
    q = deque()
    q.append((0, qty - 1))  # indexing starts at 0
    pts = [0] * qty
    pts[0] = a
    pts[-1] = b  # x0 is the first value, x1 is the last
    while len(q) != 0:
        left, right = q.popleft()  # remove working segment from queue
        center = (left + right + 1) // 2  # creates index values for pts
        pts[center] = (pts[left] + pts[right]) / 2
        if right - left > 2:  # stop when qty met
            q.append((left, center))
            q.append((center, right))
    return pts


def make_middle_points(first_x, last_x, first_y, last_y, qty):
    """line segment end points, how many midpoints, hovertext"""
    # Add 2 because the origin will be in the list, pop first and last (the nodes)
    middle_x_ = queue(first_x, last_x, qty + 2)
    middle_y_ = queue(first_y, last_y, qty + 2)
    middle_x_.pop(0)
    middle_x_.pop()
    middle_y_.pop(0)
    middle_y_.pop()
    return middle_x_, middle_y_


def make_edge(x, y, text, width, color):
    return  go.Scatter(x         = x,
                       y         = y,
                       line      = dict(width = width, color = color),
                       hoverinfo = 'text',
                       text      = ([text]),
                       mode      = 'lines')


def make_edge_middlepoints(x, y, text, opc, col):
    return  go.Scatter(x         = x,
                       y         = y,
                       marker=go.scatter.Marker(opacity=opc),
                       hovertemplate="Edge %{hovertext}<extra></extra>",
                       hovertext=text,
                       mode      = "markers",
                       marker_size = 1,
                       marker_color = col,
                       showlegend=False)


def graphjson_from_df(
        synthetic_referral: pd.DataFrame,
        output_path: str,
        minimum_referrals: Optional[int]=None,
        # degree_filter: str="Both",
        degree_filter: Optional[str]=None,
        # department_filter: Optional[int]=None,
        node_pair_efficiency: Optional[float]=None,
        department_filter: Optional[str]=None,
    ):

    """#### Loading Data"""

    # synthetic_referral = pd.read_csv('../FInal_Project/Data/synthetic_data_approximation.csv')
    synthetic_referral = synthetic_referral.rename\
                            (columns={'REFERRING_SPECIALTY': 'Referred From', \
                                    'REFERRED_TO_SPECIALTY':'Referred To',\
                                    'DAYS_TO_SCHEDULE':'Days to Schedule'})

    """#### As 'Days To Schedule' can differ for the same Source to Destination, thus taking Median 'Days To Schedule'"""

    synthetic_referral_grp = synthetic_referral.groupby(['Referred From','Referred To']).\
                apply(lambda s: pd.Series({"Median Days to Schedule": s["Days to Schedule"].median(), \
                                        "Max Days to Schedule": s["Days to Schedule"].max(), \
                                        "Min Days to Schedule": s["Days to Schedule"].min(), \
                                        "Total Days to Schedule": s["Days to Schedule"].sum(),\
                                        "count_of_appointments": s["Days to Schedule"].count()})).reset_index()

    synthetic_referral_grp['Referring_DepartmentName'] = np.where(synthetic_referral_grp['Referred From']==2,\
                                                    'Primary Care','Other')
    synthetic_referral_grp['Referred_To_DepartmentName'] = np.where(synthetic_referral_grp['Referred To']==2,\
                                                    'Primary Care','Other')

    synthetic_referral_grp['node_pair_efficiency'] = synthetic_referral_grp['count_of_appointments']/\
                                                        synthetic_referral_grp["Total Days to Schedule"]

    synthetic_referral_grp = synthetic_referral_grp.query('`Referred From` != `Referred To`')

    out_degree_count = dict(synthetic_referral_grp['Referred From'].value_counts())
    in_degree_count = dict(synthetic_referral_grp['Referred To'].value_counts())

    synthetic_referral_grp['out_degree_count'] = synthetic_referral_grp['Referred From'].map(out_degree_count)
    synthetic_referral_grp['in_degree_count'] = synthetic_referral_grp['Referred From'].map(in_degree_count)
    synthetic_referral_grp['in_degree_count'] = synthetic_referral_grp['Referred To'].map(in_degree_count)


    synthetic_referral_grp.in_degree_count.fillna(0, inplace=True)
    synthetic_referral_grp.out_degree_count.fillna(0, inplace=True)

    synthetic_referral_grp['total_degree_count'] = synthetic_referral_grp['out_degree_count']+\
                                                                synthetic_referral_grp['in_degree_count']

    synthetic_referral_grp['node_pair_efficiency_scaled'] = MinMaxScaler().fit_transform\
            (np.array(synthetic_referral_grp['node_pair_efficiency']).reshape(-1,1))

    synthetic_referral_grp['count_of_appointments_norm'] = StandardScaler().fit_transform\
            (synthetic_referral_grp[['count_of_appointments']]).flatten()

    synthetic_referral_grp['Schedule_Bins'] = \
                        np.where(synthetic_referral_grp['Median Days to Schedule']<=15, '15',
                        np.where(synthetic_referral_grp['Median Days to Schedule']<=50, '50',
                                            '50+'))

    quantiles_a = np.quantile(synthetic_referral_grp.count_of_appointments,[0,0.25,0.5,0.75,1])
    quantile_25_a = quantiles_a[1]
    quantile_50_a = quantiles_a[2]
    quantile_75_a = quantiles_a[3]

    quantiles_b = dict(synthetic_referral_grp.query\
                    (f'count_of_appointments>={quantile_75_a}')['count_of_appointments'].describe())
    quantile_25_b = quantiles_b['25%']
    quantile_50_b = quantiles_b['50%']

    quantiles_c = dict(synthetic_referral_grp.query\
                    (f'count_of_appointments>={quantile_50_b}')['count_of_appointments'].describe())

    quantile_75_c = quantiles_c['75%']

    """#### We will be using Node Pair Efficiency to calculate the edges. Efficiency is calculated by Total number of appointments divided by total days it took to schedule"""

    synthetic_referral_grp['weight'] = np.where(synthetic_referral_grp['count_of_appointments']<=quantile_50_a,0.08,
                                    np.where(synthetic_referral_grp['count_of_appointments']<=quantile_75_a,0.1,
                                    np.where(synthetic_referral_grp['count_of_appointments']<=quantile_50_b,0.25,
                                    np.where(synthetic_referral_grp['count_of_appointments']<=quantile_75_c, 0.4,
                                    2))))

    synthetic_referral_grp['Schedule_Bins_color'] = np.where(synthetic_referral_grp['Schedule_Bins']=='15', 'green',
                                    np.where(synthetic_referral_grp['Schedule_Bins']=='50','orange','red'))

    """#### Calculating Size of Node based on Number of Referrals Made OR Recevied """

    node_size_list = list(synthetic_referral['Referred From'])+list(synthetic_referral['Referred To'])

    node_size = dict()
    for i in sorted(node_size_list):
        node_size[i] = node_size.get(i, 0)+1

    node_size_scaled = pd.DataFrame(list(node_size.items()), columns=['node','appearnce_cnt'])

    node_size_list_a = list(synthetic_referral['Referred From'].unique())
    node_size_df_a = pd.DataFrame(node_size_list_a, columns=['node'])
    node_size_df_a['in-degree'] = 0
    node_size_df_a['out-degree'] = 0

    node_size_list_b = list(set(synthetic_referral['Referred To']).\
                            difference(set(synthetic_referral['Referred From'])))
    node_size_df_b = pd.DataFrame(node_size_list_b, columns=['node'])
    node_size_df_b['in-degree'] = 0
    node_size_df_b['out-degree'] = 0

    out_degree_count = dict(synthetic_referral_grp['Referred From'].value_counts())
    in_degree_count = dict(synthetic_referral_grp['Referred To'].value_counts())

    node_size_df_a['out-degree'] = node_size_df_a['node'].map(out_degree_count)
    node_size_df_a['in-degree'] = node_size_df_a['node'].map(in_degree_count)

    node_size_df_b['out-degree'] = node_size_df_b['node'].map(out_degree_count)
    node_size_df_b['in-degree'] = node_size_df_b['node'].map(in_degree_count)

    nodesize_df = pd.concat([node_size_df_a, node_size_df_b], axis=0, ignore_index=True)
    nodesize_df['in-degree'].fillna(0, inplace=True)
    nodesize_df['out-degree'].fillna(0, inplace=True)
    nodesize_df['total-degree'] = nodesize_df['in-degree']+nodesize_df['out-degree']

    #getting size of nodes based on degrees
    nodesize_df.loc[(nodesize_df['in-degree']!=0)&(nodesize_df['out-degree']!=0), 'node_size'] = \
        MinMaxScaler(feature_range=(7,25)).\
        fit_transform(nodesize_df.query('`in-degree` !=0 and `out-degree`!=0')[['total-degree']])

    nodesize_df.loc[(nodesize_df['in-degree']!=0)&(nodesize_df['out-degree']==0), 'node_size'] = \
        MinMaxScaler(feature_range=(7,25)).\
        fit_transform(nodesize_df.query('`in-degree` !=0 and `out-degree`==0')[['total-degree']])

    nodesize_df.loc[(nodesize_df['in-degree']==0)&(nodesize_df['out-degree']!=0), 'node_size'] = \
        MinMaxScaler(feature_range=(7,25)).\
        fit_transform(nodesize_df.query('`in-degree` ==0 and `out-degree`!=0')[['total-degree']])

    #getting degree dropdown
    nodesize_df.loc[(nodesize_df['in-degree']!=0)&(nodesize_df['out-degree']!=0), 'Degree_Dropdown'] = 'Both'

    nodesize_df.loc[(nodesize_df['in-degree']!=0)&(nodesize_df['out-degree']==0), 'Degree_Dropdown'] = 'In-Degree'

    nodesize_df.loc[(nodesize_df['in-degree']==0)&(nodesize_df['out-degree']!=0), 'Degree_Dropdown'] = 'Out-Degree'

    nodesize = dict(zip(nodesize_df['node'],nodesize_df['node_size']))
    degree_dropdown = dict(zip(nodesize_df['node'],nodesize_df['Degree_Dropdown']))

    """Add filters here"""

    if minimum_referrals:
        synthetic_referral_grp = synthetic_referral_grp[synthetic_referral_grp["count_of_appointments"] >= minimum_referrals]


    if department_filter and department_filter != "All":
        synthetic_referral_grp = synthetic_referral_grp.query(
            f"(`Referring_DepartmentName` == '{department_filter}') | (`Referred_To_DepartmentName` == '{department_filter}')"
        )

    if node_pair_efficiency:
        # TODO: handle case where no nodes match
        print(f"{node_pair_efficiency=}")
        synthetic_referral_grp = synthetic_referral_grp[synthetic_referral_grp["node_pair_efficiency_scaled"] >= node_pair_efficiency]


    if degree_filter and degree_filter != "All":
        if degree_filter == "Out-Degree":
            degree_dropdown_nodelist = list(nodesize_df.query(f'Degree_Dropdown=="{degree_filter}"')['node'].values)
            synthetic_referral_grp = synthetic_referral_grp.query\
            (f"`Referred From` in {degree_dropdown_nodelist}")
        elif degree_filter == "In-Degree":
            degree_dropdown_nodelist = list(nodesize_df.query(f'Degree_Dropdown=="{degree_filter}"')['node'].values)
            synthetic_referral_grp = synthetic_referral_grp.query\
            (f"`Referred To` in {degree_dropdown_nodelist}")
        else:
            degree_dropdown_nodelist = list(nodesize_df.query(f'Degree_Dropdown=="{degree_filter}"')['node'].values)
            synthetic_referral_grp = synthetic_referral_grp.query\
            (f"`Referred From` in {degree_dropdown_nodelist} | `Referred To` in {degree_dropdown_nodelist}")

    """#### Calculating Number of Outgoing and Incoming Connection For Each Node"""

    outgoing_connection =  list(synthetic_referral_grp['Referred From'])
    node_size_og = dict()
    for i in sorted(outgoing_connection):
        node_size_og[i] = node_size_og.get(i, 0)+1
        
    node_size_og = pd.DataFrame(list(node_size_og.items()), columns=['node','og_appearnce_cnt'])


    incoming_connection =  list(synthetic_referral_grp['Referred To'])
    node_size_in = dict()
    for i in sorted(incoming_connection):
        node_size_in[i] = node_size_in.get(i, 0)+1

    # outgoing_connection =  list(synthetic_referral['Referred From'])
    # node_size_og = dict()
    # for i in sorted(outgoing_connection):
    #     node_size_og[i] = node_size_og.get(i, 0)+1
        
    # node_size_og = pd.DataFrame(list(node_size_og.items()), columns=['node','og_appearnce_cnt'])


    # incoming_connection =  list(synthetic_referral['Referred To'])
    # node_size_in = dict()
    # for i in sorted(incoming_connection):
    #     node_size_in[i] = node_size_in.get(i, 0)+1
        
    node_size_ic = pd.DataFrame(list(node_size_in.items()), columns=['node','in_appearnce_cnt'])

    G = nx.from_pandas_edgelist(synthetic_referral_grp,source='Referred From',target='Referred To',\
                                create_using=nx.Graph())
    pos = nx.spring_layout(G, seed=56)

    G = nx.from_pandas_edgelist(synthetic_referral_grp,source='Referred From',target='Referred To',\
                                edge_attr='weight', create_using=nx.Graph())

    """**Calculating Key Metrics**

    **Top 5 Most Influencing Depatments, which has a very high connection with other departments in decreasing order. You can show this metric in Flask if possible**
    """

    dict_eigenvector_centrality = nx.eigenvector_centrality(G)
    dict_eigenvector_centrality = sorted(dict_eigenvector_centrality.items(), key=lambda x:x[1], reverse=True)

    # print("Top 5 Most Influencing Depatments, which has a very high \
    # connection with other departments in decreasing order. In our case 2 is supposed to be the most influencing\
    # part of the network since the network data focuses on 2 i.e. Primary Care.")
    # for i in dict_eigenvector_centrality[:5]:
    #     print("Department: ",i[0])

    dict_degree_centrality = nx.degree_centrality(G)
    dict_degree_centrality = sorted(dict_degree_centrality.items(), key=lambda x:x[1], reverse=True)

    # print("Top 5 Most central nodes in our network is shown below. We can see that this time 19 which was not in \
    # the previous list.This is because degree centrality is in our list as degree centrality. \
    # This is because Node 19 is connected with more nodes compared to node 10. Node 10 has lesser conneection \
    # than node 19 but is connected to more infuential nodes in the network. Node 19 is not connected with such nodes\
    # for e.g. we found it is only connected with 2 and not with 7, 10 etc")
    # for i in dict_degree_centrality[:5]:
    #     print("Department: ",i[0])





    """#### Trying To Build Graph With Plotly"""

    referral = G
    pos_ = pos

    EDGE_POINTS_QUANTITY = 20
    EDGE_POINTS_OPACITY = 0.01

    edge_trace = []
    edge_md_trace = []

    for edge in referral.edges():
        
        #if referral.edges()[edge]['weight'] > 0.5:
        char_1 = edge[0]
        char_2 = edge[1]

        x0, y0 = pos_[char_1]
        x1, y1 = pos_[char_2]

        text   = ''#str(char_1) + '--' + str(char_2) + ': ' + str(referral.edges()[edge]['weight'])
        
        col = ''
        color_line = synthetic_referral_grp.query(f'`Referred From`=={char_1} & `Referred To`=={char_2}')
        
        if not(color_line.empty):
            col = color_line['Schedule_Bins_color'].item()
        else:
            color_line = synthetic_referral_grp.query(f'`Referred To`=={char_1} & `Referred From`=={char_2}')
            col = color_line['Schedule_Bins_color'].item()

        trace  = make_edge([x0, x1, None], [y0, y1, None], text, referral.edges()[edge]['weight'], col)
                        #0.002*referral.edges()[edge]['weight']**2)
            
        edge_trace.append(trace)
        
        edge_width_condition = color_line['weight'].item()
        if(edge_width_condition>=0.25):
            median_days_to_schedule = color_line['Median Days to Schedule'].item()
            max_days_to_schedule = color_line['Max Days to Schedule'].item()
            min_days_to_schedule = color_line['Min Days to Schedule'].item()
            number_of_encounters = color_line['count_of_appointments'].item()
            edge_middle_x, edge_middle_y, edge_middle_text = [], [], []
            middle_x, middle_y = make_middle_points(x0, x1, y0, y1, EDGE_POINTS_QUANTITY)
            edge_middle_x.extend(middle_x)
            edge_middle_y.extend(middle_y)
            edge_middle_text.extend([f"{char_1} - {char_2}<br>Median Days To Schedule {median_days_to_schedule}<br>Max Days To Schedule {max_days_to_schedule}<br>Min Days To Schedule {min_days_to_schedule}<br>Number of Encounters {number_of_encounters}"] * EDGE_POINTS_QUANTITY)

            trace = make_edge_middlepoints(edge_middle_x,edge_middle_y,edge_middle_text,EDGE_POINTS_OPACITY,col)
            edge_md_trace.append(trace)

    # Make a node trace
    node_trace = go.Scatter(x         = [],
                            y         = [],
                            text      = [],
                            textposition = "top center",
                            textfont_size = 7,
                            mode      = 'markers+text',
                            hoverinfo = 'text',
                            hovertext = ([text]),
                            marker    = dict(color = [],
                                            size  = [],
                                            line  = None))

    # TODO: does not work with high minimum referrals (e.g., 1000) and primary care
    common_nodes = list(nodesize_df.query('`in-degree` != 0 and `out-degree`!= 0')['node'])

    # For each node in referral, get the position and size and add to the node_trace
    for node in referral.nodes():
        x, y = pos_[node]
        node_trace['x'] += tuple([x])
        node_trace['y'] += tuple([y])
        
        if(node in common_nodes):
            node_trace['marker']['color'] += tuple(['#35978f'])
        elif(node in list(node_size_og.node)):
            node_trace['marker']['color'] += tuple(['#543005'])
        else:
            node_trace['marker']['color'] += tuple(['#dfc27d'])
        
        
        node_trace['marker']['size'] += tuple([nodesize[node]])
        
        node_trace['text'] += tuple(['<b>' + str(node) + '</b>'])
        
        n_ofconnections = node_size_scaled.query(f'node=={node}')['appearnce_cnt'].item()
        
        n_outdegree = 0
        n_indegree = 0 
        n_ogconnections = 0
        n_icconnections = 0
        if not(nodesize_df.query(f'node=={node}').empty):
            n_outdegree = nodesize_df.query(f'node=={node}')['out-degree'].item()
            
        if not(node_size_og.query(f'node=={node}').empty):
            n_ogconnections = node_size_og.query(f'node=={node}')['og_appearnce_cnt'].item()
        
        if not(nodesize_df.query(f'node=={node}').empty):
            n_indegree = nodesize_df.query(f'node=={node}')['in-degree'].item()
            
        if not(node_size_ic.query(f'node=={node}').empty):
            n_icconnections = node_size_ic.query(f'node=={node}')['in_appearnce_cnt'].item()
            
    #     node_trace['hovertext'] += tuple(['<b>' + 'node:</b>'+ str(node) + '<br>' \
    #                                 + '<b>#connections:</b>' + str(n_ofconnections) + '</br>'])
        
        node_trace['hovertext'] += tuple(['<b>' + 'node:</b>'+ str(node) + '<br>' \
                                + '<b>#total referrals:</b>' + str(n_ofconnections) + '<br>'
                                + '<b>#referrals made:</b>' + str(n_ogconnections) + '<br>'
                                + '<b>#referrals received:</b>' + str(n_icconnections) + '<br>'
                                + '<b>out degree:</b>' + str(n_outdegree) + '<br>'    
                                + '<b>in degree:</b>' + str(n_indegree) + '</br>'                                 
                                        ])

    x = list(node_trace.hovertext)
    x.pop(0)
    node_trace.hovertext = x
    # width=1000
    # height=700

    layout = go.Layout(
        paper_bgcolor='rgba(0,0,0,0)',
        plot_bgcolor='rgba(0,0,0,0)'
    )


    fig = go.Figure(layout = layout)


    for trace in edge_trace:
        fig.add_trace(trace)

    for trace in edge_md_trace:
        fig.add_trace(trace)

    fig.add_trace(node_trace)

    fig.update_layout(
        showlegend = False,
        title=go.layout.Title(
            text="Network of Referrals <br>"\
                +"<sup>The larger the node, the more connected it is to other departments.<br></sup>",
            xref="paper",
            x=0
        ),
        margin_b=90
    )


    fig.update_xaxes(showticklabels = False)

    fig.update_yaxes(showticklabels = False)

    # fig.show()

    # py.plot(fig, filename='referrals4h_flask.html')

    with open(output_path, "w") as graph_json:
        json.dump(fig, graph_json, cls=plotly.utils.PlotlyJSONEncoder)

